Here I try to jot down what I do in the project, thoughts on what to do later and different approaches to problems I encounter.
Probably should divide it to two files: One more strict with updateson all commits and merges and one more free.

I have set up the serverless project.
Defined db-tables.
Added stumps for (most of) the required functions.
Added endpoints in serverless.yml
Added boilerplate code for signUp and login, and sendResponse.

Switched to postNote branch.

Fixed import errors

Deployed to aws:
- signUp works
-logIn works
(Not much error handling yet)

Added basic postNote function.
Deployed
Committed  and pushed to postNote branch:
postNoteAddedFixedImportErrors

Tested with Insomnia:
Now it is possible to post a note

Merged and deleted branch postNote

Switched to getNotes branch

Added getNotes
Added verifyToken

Committed and pushed to getNotes branch:
addedGetNotesAndVerifyToken

Merged and deleted getNotes branch

Fixed small bugs, pushed directly to main.

Deployed.
getNotes works, but it gets all notes since auth isn't implemented in postNote

Switched to new branch: workingBranch - I need to get auth to work and probably will work on multiple files.

--------------------------------------------------------------------
I'm thinking of how to implement a trashcan and update history.
So far I have four approaches to consider:
1: Keep all notes in one table. Then I have to make the note object a bit more complex: It should have a property called 'deleted' or something which is false to start with and changes to true on deletion. All updates should be kept inside the object in a history property. Something like this:
{
    userId: "klfkajdgjhaevjkd758gf",
    noteId: "aslh67986798asfgjkadt",
    createdAt: "2023-11-24",//well, maybe a Date object
    modifiedAt: "2023-11-28", // Latest updated
    title: "Example", // Here is the latest update
    text: "This is just an example!", // Here is the latest update
    deleted: false,
    history: { // Here are the earlier versions
        {
            modifiedAt: "2023-11-24", // First version
            title: "Exmpel",
            text: "Det h채r 채r ett exempel"
        },
        {
            modifiedAt: "2023-11-25", // second
            title: "Exempel",
            text: "Det h채r 채r bara ett exempel"
        },
    }
}
This is pretty straightforward, but the Note objects could grow in size. Because of this I think the other approach might work better:

2: I could move the history to a separate table. But what should the key be? I am using userId and noteId as key for my notes table.
In the history table, there will be more than one note with a
specific id. So I should probably use the mofifiedAt property. Or I could make a more complex object, like in the first approach. I am leaning towards this at the moment.

3: Or should I have three tables?
One with current note, one with history, one trashcan.

4: Or, again two tables: My first option but with a trashcan where I move notes, history and all, on delete.

UPDATE: Ok, it seems I just have to implement the trashcan functionallity. I'll start with just a 'deleted' property, I think.
Maybe I'll add the history later.
-------------------------------------------------------------------

-------------------------------------------------------------------
Dates! How? I think I'll use UTC.
- I just convert the Date to an isoString. Seems to be in UTC format.
-------------------------------------------------------------------

I have implemented verifyToken to postNote.
And fixed the dates, now an isoString.
Now notes gets the logged in user's userid.

I fixed getNotes to only fetch the logged in user's notes.

Added isDeleted property and updated getNotes to only get notes that isn't deleted.

Added archiveNote, that sets isDeleted to true.
And unArchiveNote, which resets isDeleted to false.

Added a getArchivedNotes function.

upDateNote works! I changed the endpoint to /api/notes/{noteId}, though.

deleteArchivedNote seems to work, too!

I should add a check so only an unarchived note can be updated!